import scipy.fft
import numpy as np
import matplotlib.pyplot as plt

def calc_spec(B_vec, K, L=None, shift_onesided=1):
	"""
	Arguments:
		B_vec: 3-axis numpy array.
			Represents the Fourier-transformed 3D B-vector in a 2D slice. The first index denotes the vector components. A right-handed coordinate system is assumed, with the first unit vector being in the direction normal to the slice. The remaining two axes iterate over the Fourier wavevectors within the slice, with the wavenumber ordering being that used by scipy.fft.fftfreq. Such an array can be generated by the function get_B_vec.
		K: 2-element numpy array.
			Large-scale wavevector to handle. The true wavevector is 2*pi*K/min(L)
		L: 2-element numpy array.
			Length of the domain along the spatial directions. Default: np.array([2*np.pi, 2*np.pi])
		shift_onesided: int
			Possible values are:
				1: Mij = B_i(k+K) B_j^*(k) (the one used in Nishant's 2018 paper)
				0: Mij = B_i(k+K/2) B_j^*(k-K/2) (the correct definition)
				-1: Mij = B_i(k) B_j^*(k-K) (a possible alternate definition)
	"""
	
	if L is None:
		L = np.array([2*np.pi, 2*np.pi])
	if isinstance(shift_onesided, bool):
		#For compatibility with old versions of the code.
		shift_onesided = int(shift_onesided)
	
	if shift_onesided == 1:
		Mij = np.roll(B_vec, shift=np.round(-K).astype(int), axis=(1,2))[:,None,:,:]*np.conj(B_vec)[None,:,:,:]
	elif shift_onesided == 0:
		#NOTE: Below, if K=(0,1), K/2 will just be rounded to (0,0), resulting in no shift being applied. The one-sided shift used above is a workaround for that
		Mij = np.roll(B_vec, shift=np.round(-K/2).astype(int), axis=(1,2))[:,None,:,:]*np.roll(np.conj(B_vec), shift=np.round(K/2).astype(int), axis=(1,2))[None,:,:,:]
	elif shift_onesided == -1:
		Mij = B_vec[:,None,:,:]*np.conj(np.roll(B_vec, shift=np.round(K).astype(int), axis=(1,2)))[None,:,:,:]
	else:
		raise ValueError(f"Invalid {shift_onesided =}")
	
	#Approximate wavenumbers in both the directions
	_, n_lon, n_lat = np.shape(B_vec)
	L_lon, L_lat = L
	
	L_min = min(L) #We use this to make the wavevector an integer (to ease binning). All 'wavevectors' below then need to be multiplied by 2pi/L to get the actual wavevector.
	nk = int(np.min(np.floor(np.array([n_lat,n_lon])/2))) #Maximum 'magnitude' of the wavevectors
	k_lat = L_min*n_lat*scipy.fft.fftfreq(n_lat, d=L_lat)
	k_lon = L_min*n_lon*scipy.fft.fftfreq(n_lon, d=L_lon)
	
	k_lon_g, k_lat_g = np.meshgrid(k_lon, k_lat, indexing='ij')
	k_rad_g = np.zeros_like(k_lat_g)
	k_vec = np.stack([k_rad_g, k_lon_g, k_lat_g])
	k_mag = np.sqrt(np.sum(k_vec**2, axis=0))
	k_mag_round = np.round(k_mag) #Used to bin the spectra
	
	E = np.zeros(nk, dtype=complex)
	H = np.zeros(nk, dtype=complex)
	
	E_integrand = np.einsum("ii...", Mij)/2
	H_integrand = np.where(k_mag!=0, 1j*np.einsum("ii...", np.cross(k_vec, Mij, axis=0))/k_mag**2, 0)
	
	for k in range(nk):
		E[...,k] = np.sum(np.where(k_mag_round == k, E_integrand, 0), axis=(-1,-2))
		H[...,k] = np.sum(np.where(k_mag_round == k, H_integrand, 0), axis=(-1,-2))
	
	scl = (2*np.pi/L_min)
	k = np.arange(nk)
	return k*scl, E/scl**3, H/scl**4

def signed_loglog_plot(k, spec, ax, line_params=None):
	where_pos = np.where(spec>=0)[0]
	where_neg = np.where(spec<0)[0]
	spec = np.abs(spec)
	
	params_pos = {'facecolors':'none', 'edgecolors':'r', 'marker':'o'}
	params_neg = {'c':'b', 'marker':'o'}
	if line_params is None:
		line_params = dict()
	
	l1 = ax.loglog(k, spec, **line_params)[0]
	l2 = ax.scatter(k[where_pos], spec[where_pos], **params_pos, label="$+$")
	l3 = ax.scatter(k[where_neg], spec[where_neg], **params_neg, label="$-$")
	
	return [l1, l2, l3]

if __name__ == "__main__":
	from read_FITS import get_B_vec
	
	L = np.array([360,2])
	B_vec = get_B_vec("images/hmi.b_synoptic_small.2267")
	
	k, E0, _ = calc_spec(B_vec, K=np.array([0,0]), L=L)
	_, _, H1 = calc_spec(B_vec, K=np.array([0,1]), L=L)
	
	_, _, H2_I = calc_spec(B_vec, K=np.array([0,2]), L=L)
	_, _, H2 = calc_spec(B_vec, K=np.array([0,2]), L=L, shift_onesided=False)
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(k*H1), ax, {'label':"-np.imag(k*H(k,1))"})
	h = ax.loglog(k, E0, label="E(k,0)")
	handles.extend(h)
	ax.set_xlabel("k")
	ax.set_title("using sin(latitude) grid")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(H2), ax, {'label':"Python"})
	h2, *_ = signed_loglog_plot(k, -np.imag(H2_I)/100, ax, {'label':"IDL/100"})
	handles.append(h2)
	ax.set_ylabel("-np.imag(H(k,2))")
	ax.set_xlabel("k")
	ax.set_title("using sin(latitude) grid")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	L_rebin = np.array([360,180])
	B_vec_rebin = get_B_vec("images/hmi.b_synoptic_small.rebinned.2267")
	k_rebin, E0_rebin, _ = calc_spec(B_vec_rebin, K=np.array([0,0]), L=L)
	_, _, H1_rebin = calc_spec(B_vec_rebin, K=np.array([0,1]), L=L)
	
	fig,ax = plt.subplots()
	ax.loglog(k_rebin, E0, label="original")
	ax.loglog(k_rebin, E0_rebin, label="rebinned")
	ax.set_ylabel("E(k,0)")
	ax.set_xlabel("k")
	ax.legend()
	fig.tight_layout()
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(k*H1_rebin), ax, {'label':"-np.imag(k*H(k,1))"})
	h = ax.loglog(k, E0_rebin, label="E(k,0)")
	handles.extend(h)
	ax.set_xlabel("k")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	plt.show()
