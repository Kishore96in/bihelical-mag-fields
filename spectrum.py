from astropy.io import fits
import scipy.fft
import numpy as np
import matplotlib.pyplot as plt

from read_FITS import get_B_vec

def calc_spec(B_vec, K, L=None, shift_onesided=True):
	"""
	Arguments:
		B_vec: numpy array representing the Fourier-transformed B-vector, with shape (3,n_lon,n_lat). It can be generated by the function get_B_vec
		K: 2-element numpy array, large-scale wavevector to handle. The true wavevector is 2*pi*K/min(L)
		L: 2-element numpy array, length of the domain along the longitudinal and latitudinal directions. Default: np.array([2*np.pi, 2*np.pi])
		shift_onesided: bool
			True: Mij = B_i(k+K) B_j^*(k) (the one used in Nishant's 2018 paper)
			False: Mij = B_i(k+K/2) B_j^*(k-K/2) (the correct definition)
	"""
	
	if L is None:
		L = np.array([2*np.pi, 2*np.pi])
	
	#Approximate wavenumbers in both the directions
	_, n_lon, n_lat = np.shape(B_vec)
	L_lon, L_lat = L
	
	L_min = min(L) #We use this to make the wavevector an integer (to ease binning). All 'wavevectors' below then need to be multiplied by 2pi/L to get the actual wavevector.
	nk = int(np.min(np.floor(np.array([n_lat,n_lon])/2))) #Maximum 'magnitude' of the wavevectors
	k_lat = L_min*n_lat*scipy.fft.fftfreq(n_lat, d=L_lat)
	k_lon = L_min*n_lon*scipy.fft.fftfreq(n_lon, d=L_lon)
	
	k_lon_g, k_lat_g = np.meshgrid(k_lon, k_lat, indexing='ij')
	k_rad_g = np.zeros_like(k_lat_g)
	k_vec = np.stack([k_rad_g, k_lon_g, k_lat_g])
	k_mag = np.sqrt(np.sum(k_vec**2, axis=0))
	k_mag_round = np.round(k_mag) #Used to bin the spectra
	
	if shift_onesided:
		Mij = np.roll(B_vec, shift=np.round(-K).astype(int), axis=(1,2))[:,None,:,:]*np.conj(B_vec)[None,:,:,:]
	else:
		#NOTE: Below, if K=(0,1), K/2 will just be rounded to (0,0), resulting in no shift being applied. The one-sided shift used above is a workaround for that
		Mij = np.roll(B_vec, shift=np.round(-K/2).astype(int), axis=(1,2))[:,None,:,:]*np.roll(np.conj(B_vec), shift=np.round(K/2).astype(int), axis=(1,2))[None,:,:,:]
	
	E = np.zeros(nk, dtype=complex)
	H = np.zeros(nk, dtype=complex)
	
	E_integrand = np.einsum("ii...", Mij)/2
	H_integrand = 1j*np.einsum("ii...", np.cross(k_vec, Mij, axis=0))/k_mag**2
	
	for k in range(nk):
		E[...,k] = np.sum(np.where(k_mag_round == k, E_integrand, 0), axis=(-1,-2))
		H[...,k] = np.sum(np.where(k_mag_round == k, H_integrand, 0), axis=(-1,-2))
	
	scl = (2*np.pi/L_min)
	k = np.arange(nk)
	return k*scl, E/scl**3, H/scl**4

def signed_loglog_plot(k, spec, ax, line_params=None):
	where_pos = np.where(spec>=0)[0]
	where_neg = np.where(spec<0)[0]
	spec = np.abs(spec)
	
	params_pos = {'facecolors':'none', 'edgecolors':'r', 'marker':'o'}
	params_neg = {'c':'b', 'marker':'o'}
	if line_params is None:
		line_params = dict()
	
	l1 = ax.loglog(k, spec, **line_params)[0]
	l2 = ax.scatter(k[where_pos], spec[where_pos], **params_pos, label="positive")
	l3 = ax.scatter(k[where_neg], spec[where_neg], **params_neg, label="negative")
	
	return [l1, l2, l3]

if __name__ == "__main__":
	L = np.array([360,2])
	B_vec = get_B_vec("images/hmi.b_synoptic_small.2267")
	
	k, E0, _ = calc_spec(B_vec, K=np.array([0,0]), L=L)
	_, _, H1 = calc_spec(B_vec, K=np.array([0,1]), L=L)
	
	_, _, H2_I = calc_spec(B_vec, K=np.array([0,2]), L=L)
	_, _, H2 = calc_spec(B_vec, K=np.array([0,2]), L=L, shift_onesided=False)
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(k*H1), ax, {'label':"-np.imag(k*H(k,1))"})
	h = ax.loglog(k, E0, label="E(k,0)")
	handles.extend(h)
	ax.set_xlabel("k")
	ax.set_title("using sin(latitude) grid")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(H2), ax, {'label':"Python"})
	h2, *_ = signed_loglog_plot(k, -np.imag(H2_I)/100, ax, {'label':"IDL/100"})
	handles.append(h2)
	ax.set_ylabel("-np.imag(H(k,2))")
	ax.set_xlabel("k")
	ax.set_title("using sin(latitude) grid")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	L_rebin = np.array([360,180])
	B_vec_rebin = get_B_vec("images/hmi.b_synoptic_small.rebinned.2267")
	k_rebin, E0_rebin, _ = calc_spec(B_vec_rebin, K=np.array([0,0]), L=L)
	_, _, H1_rebin = calc_spec(B_vec_rebin, K=np.array([0,1]), L=L)
	
	fig,ax = plt.subplots()
	ax.loglog(k_rebin, E0, label="original")
	ax.loglog(k_rebin, E0_rebin, label="rebinned")
	ax.set_ylabel("E(k,0)")
	ax.set_xlabel("k")
	ax.legend()
	fig.tight_layout()
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(k*H1_rebin), ax, {'label':"-np.imag(k*H(k,1))"})
	h = ax.loglog(k, E0_rebin, label="E(k,0)")
	handles.extend(h)
	ax.set_xlabel("k")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	plt.show()
