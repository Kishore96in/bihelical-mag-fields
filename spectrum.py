import scipy.fft
import numpy as np
import matplotlib.pyplot as plt

class calc_spec():
	def __new__(self, B_vec, K, L=None, shift_onesided=1):
		"""
		Arguments:
			B_vec: 3-axis numpy array.
				Represents the Fourier-transformed 3D B-vector in a 2D slice. The first index denotes the vector components. A right-handed coordinate system is assumed, with the first unit vector being in the direction normal to the slice. The remaining two axes iterate over the Fourier wavevectors within the slice, with the wavenumber ordering being that used by scipy.fft.fftfreq. Such an array can be generated by the class HMIreader.
			K: 2-element numpy array.
				Large-scale wavevector to handle. The true wavevector is 2*pi*K/min(L)
			L: 2-element numpy array.
				Length of the domain along the spatial directions. Default: np.array([2*np.pi, 2*np.pi])
			shift_onesided: int
				Possible values are:
					1: Mij = B_i(k+K) B_j^*(k) (the one used in Nishant's 2018 paper)
					0: Mij = B_i(k+K/2) B_j^*(k-K/2) (the correct definition)
					-1: Mij = B_i(k) B_j^*(k-K) (a possible alternate definition)
		"""
		
		if L is None:
			L = np.array([2*np.pi, 2*np.pi])
		if isinstance(shift_onesided, bool):
			#For compatibility with old versions of the code.
			shift_onesided = int(shift_onesided)
		
		if shift_onesided == 1:
			Mij = np.roll(B_vec, shift=self.round(-K).astype(int), axis=(1,2))[:,None,:,:]*np.conj(B_vec)[None,:,:,:]
		elif shift_onesided == 0:
			#NOTE: Below, if K=(0,1), K/2 will just be rounded to (0,0), resulting in no shift being applied. The one-sided shift used above is a workaround for that
			Mij = np.roll(B_vec, shift=self.round(-K/2).astype(int), axis=(1,2))[:,None,:,:]*np.roll(np.conj(B_vec), shift=self.round(K/2).astype(int), axis=(1,2))[None,:,:,:]
		elif shift_onesided == -1:
			Mij = B_vec[:,None,:,:]*np.conj(np.roll(B_vec, shift=self.round(K).astype(int), axis=(1,2)))[None,:,:,:]
		else:
			raise ValueError(f"Invalid {shift_onesided =}")
		
		#Approximate wavenumbers in both the directions
		_, n_lon, n_lat = np.shape(B_vec)
		L_lon, L_lat = L
		
		L_min = min(L) #We use this to make the wavevector an integer (to ease binning). All 'wavevectors' below then need to be multiplied by 2pi/L to get the actual wavevector.
		nk = int(np.min(np.floor(np.array([n_lat,n_lon])/2))) #Maximum 'magnitude' of the wavevectors
		k_lat = L_min*n_lat*scipy.fft.fftfreq(n_lat, d=L_lat)
		k_lon = L_min*n_lon*scipy.fft.fftfreq(n_lon, d=L_lon)
		
		k_lon_g, k_lat_g = np.meshgrid(k_lon, k_lat, indexing='ij')
		k_rad_g = np.zeros_like(k_lat_g)
		k_vec = np.stack([k_rad_g, k_lon_g, k_lat_g])
		k_mag = np.sqrt(np.sum(k_vec**2, axis=0))
		k_mag_round = self.round(k_mag) #Used to bin the spectra
		
		E = np.zeros(nk, dtype=complex)
		H = np.zeros(nk, dtype=complex)
		
		E_integrand = np.einsum("ii...", Mij)/2
		
		k_mag_inv = 1/np.where(k_mag!=0, k_mag, 1) #Prevent divide-by-zero warning.
		H_integrand = 1j*np.einsum("ii...", np.cross(k_vec, Mij, axis=0))*k_mag_inv**2
		
		for k in range(nk):
			#TODO: I guess ... below is not needed now (since E and H have only one axis), but does no harm.
			E[...,k] = np.sum(np.where(k_mag_round == k, E_integrand, 0), axis=(-1,-2))
			H[...,k] = np.sum(np.where(k_mag_round == k, H_integrand, 0), axis=(-1,-2))
		
		scl = (2*np.pi/L_min)
		k = np.arange(nk)
		return k*scl, *self.scale_EH(E, H, scl)
	
	def round(arr):
		return np.round(arr)
	
	@staticmethod
	def scale_EH(E, H, scl=1):
		"""
		Dimensional scaling for E and H. The scaling here corresponds to E having units G^2.Mm^3
		"""
		return E/scl**3, H/scl**4

class calc_spec_G2(calc_spec):
	@staticmethod
	def scale_EH(E, H, scl=1):
		"""
		Dimensional scaling for E and H. The scaling here corresponds to E having units G^2 (i.e. erg.cm^{-3})
		"""
		return E, H/scl

class calc_spec_SI(calc_spec):
	@staticmethod
	def scale_EH(E, H, scl=1):
		"""
		Dimensional scaling for E and H. The scaling here corresponds to E having units J.m^{-3} (we assume that the magnetic field was given in Gauss, use the fact that G^2 = erg.cm^{-3}, and then recall that 1 erg.cm^{-3} = 1e-1 J.m^{-3}).
		"""
		return 1e-1*E, 1e-1*H/scl

def signed_loglog_plot(k, spec, ax, line_params=None, err=None, **kwargs):
	"""
	Arguments:
		k: numpy array. Horizontal coordinates
		spec: numpy array. Vertical coordinates
		line_params: dict. kwargs to be passed to ax.plot. Usage of this is discouraged; just directly pass a kwarg instead.
		err: numpy array. Error in spec. If this is passed, fill_between will be used to indicate the errors.
	"""
	where_pos = np.where(spec>=0)[0]
	where_neg = np.where(spec<0)[0]
	spec = np.abs(spec)
	
	params_pos = {'facecolors':'none', 'edgecolors':'r', 'marker':'o'}
	params_neg = {'c':'b', 'marker':'o'}
	if line_params is None:
		line_params = dict()
	
	[l1] = ax.loglog(k, spec, **line_params, **kwargs)
	
	if err is not None:
		le = ax.fill_between(
			k,
			spec - err,
			spec + err,
			alpha = 0.25,
			color = l1.get_color(),
			linewidth = 0, #prevent an outline being drawn around the boundary of the region being filled.
			)
	
	l2 = ax.scatter(k[where_pos], spec[where_pos], **params_pos, label="$+$")
	l3 = ax.scatter(k[where_neg], spec[where_neg], **params_neg, label="$-$")
	
	return [l1, l2, l3]

if __name__ == "__main__":
	from read_FITS import HMIreader
	read = HMIreader()
	
	L = np.array([360,2])
	B_vec = read("images/hmi.b_synoptic_small.2267")
	
	k, E0, _ = calc_spec(B_vec, K=np.array([0,0]), L=L)
	_, _, H1 = calc_spec(B_vec, K=np.array([0,1]), L=L)
	
	_, _, H2_I = calc_spec(B_vec, K=np.array([0,2]), L=L)
	_, _, H2 = calc_spec(B_vec, K=np.array([0,2]), L=L, shift_onesided=False)
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(k*H1), ax, {'label':"-np.imag(k*H(k,1))"})
	h = ax.loglog(k, E0, label="E(k,0)")
	handles.extend(h)
	ax.set_xlabel("k")
	ax.set_title("using sin(latitude) grid")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(H2), ax, {'label':"Python"})
	h2, *_ = signed_loglog_plot(k, -np.imag(H2_I)/100, ax, {'label':"IDL/100"})
	handles.append(h2)
	ax.set_ylabel("-np.imag(H(k,2))")
	ax.set_xlabel("k")
	ax.set_title("using sin(latitude) grid")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	L_rebin = np.array([360,180])
	B_vec_rebin = read("images/hmi.b_synoptic_small.rebinned.2267")
	k_rebin, E0_rebin, _ = calc_spec(B_vec_rebin, K=np.array([0,0]), L=L)
	_, _, H1_rebin = calc_spec(B_vec_rebin, K=np.array([0,1]), L=L)
	
	fig,ax = plt.subplots()
	ax.loglog(k_rebin, E0, label="original")
	ax.loglog(k_rebin, E0_rebin, label="rebinned")
	ax.set_ylabel("E(k,0)")
	ax.set_xlabel("k")
	ax.legend()
	fig.tight_layout()
	
	fig,ax = plt.subplots()
	handles = signed_loglog_plot(k, -np.imag(k*H1_rebin), ax, {'label':"-np.imag(k*H(k,1))"})
	h = ax.loglog(k, E0_rebin, label="E(k,0)")
	handles.extend(h)
	ax.set_xlabel("k")
	ax.legend(handles=handles)
	fig.tight_layout()
	
	plt.show()

def _fourier(a, k_axes):
	"""
	Calculate fourier transform over the required axes
	"""
	n = np.array(np.shape(a), dtype=int)
	ft = a
	for ax in k_axes:
		ft = scipy.fft.fft(ft, axis=ax)/n[ax]
	return ft

def _inv_fourier(a, k_axes):
	"""
	Inverse of fourier
	"""
	n = np.array(np.shape(a), dtype=int)
	ft = a
	for ax in k_axes:
		ft = scipy.fft.ifft(ft, axis=ax)*n[ax]
	return ft

def _generate_wavevectors(n, k_axes):
	"""
	Find the wavevector corresponding to each point in the multidimensional Fourier transform of an array.
	E.g. if
	```
	#len(np.shape(a)) == 3
	ft = fourier(a, [0,1,2])
	k = generate_wavevectors(np.array(np.shape(a), dtype=int), [0,1,2])
	```
	ft[i,j,k] corresponds to wavevector k[:,i,j,k]
	
	The returned array needs to be multiplied by 2pi/{Lx,Ly,Lz} to get the actual wavevectors.
	"""
	ki = []
	for ax in k_axes:
		ki.append( np.roll( np.arange(np.ceil(-n[ax]/2),np.ceil(n[ax]/2)), int(np.ceil(n[ax]/2)) ) )
	
	ki_arr = np.meshgrid(*ki, indexing='ij')
	
	return np.array(ki_arr)

def _generate_wavenumbers(n, k_axes, L):
	"""
	NOTE: In Pencil code (power_spectrum.f90), the following just seems to be calculated as k=nint(sqrt(kx(ikx+ipx*nx)**2+ky(iky+ipy*ny)**2+kz(ikz+ipz*nz)**2)) (i.e. without accounting for having different L along each direction)
	
	See commit 4b324bd9aee20c0c62b936352748763bba48caa0 (in Pencil git repo), which suggests the one in Pencil is wrong for non-cubical boxes.
		Author: Axel Brandenburg <brandenb@nordita.org>
		Date:   Tue Mar 14 14:57:15 2006 +0000
		In power_spectrum.f90; made kx,ky,kz going only in integers. Works only
		for cubes, but now it works at least for Lx,Ly,Lz different from 2*pi,
		which was a problem for all interstellar runs.
	
	Recall that along each axis, the spacing between Fourier modes is 2*pi/L[i]. We choose min(L) below to ensure that we use the coarsest Fourier-binning among the given axes.
	"""
	ki_arr = _generate_wavevectors(n, k_axes)
	k_arr = np.round(np.min(L)*np.sqrt(np.sum([ (ki_arr[i]/L[i])**2 for i in range(len(k_axes))], axis=0)))
	
	return k_arr

def filter_fourier(
	a,
	k_min,
	k_max,
	k_axes,
	L=None,
	validate_input=True,
	):
	"""
	Given a field a, filter it by removing all Fourier modes outside the semi-open interval [k_min,k_max).
	
	Arguments:
		a: numpy array
		k_min: float, smallest wavenumber to allow
		k_max: float, largest wavenumber to allow
		k_axes: list, axes of a which should be Fourier-transformed
		L: list, domain size along the directions given by k_axes (default: 2pi)
	
	Returns:
		a_filt: filtered array of same shape as a.
	"""
	if L is None:
		#Length of the domain. Important in case grid spacing is different in different directions.
		L = np.full(len(k_axes), 2*np.pi)
	
	#Cast the passed arguments to the correct types.
	k_axes = np.array(k_axes, dtype=int)
	L = np.array(L)
	
	if validate_input:
		for ax in k_axes:
			try:
				np.shape(a)[ax]
			except IndexError:
				raise RuntimeError("Specified axis {} does not exist".format(ax))
		if len(L) != len(k_axes):
			raise RuntimeError("L and k_axes should be of same length")
	
	"""
	Transpose array such that k_axes are contiguous, increasing, and at the end of the array.
	This is an assumption we make for easy vectorization (see the broadcasting of k_arr).
	"""
	n = np.array(np.shape(a), dtype=int)
	newaxes = list(range(len(n)))
	sort = np.argsort(k_axes)
	for k in k_axes[sort]:
		if k < 0:
			k = len(n) + k
		newaxes.remove(k)
		newaxes.append(k)
	a = np.transpose(a, axes=newaxes)
	L = L[sort]
	k_axes = k_axes[sort]
	
	k_arr = (2*np.pi/min(L))*_generate_wavenumbers(n, k_axes, L)
	k_arr = k_arr[tuple([None]*(len(n)-len(k_axes)) + [slice(None)]*len(k_axes))] #Broadcast so it is compatible with the input array 'a'
	
	a_ft = _fourier(a, k_axes)
	a_ft_filt = np.where(np.logical_and(k_arr>=k_min, k_arr<k_max), a_ft, 0)
	a_filt = _inv_fourier(a_ft_filt, k_axes)
	
	if np.isrealobj(a):
		#Try to cast to real if the input array was real.
		a_filt = np.real_if_close(a_filt)
	
	return np.transpose(a_filt, axes=newaxes)
